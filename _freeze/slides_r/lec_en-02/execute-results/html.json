{
  "hash": "90a954c9a4062f55c5039885dbce497f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Getting the data in R\"\nsubtitle: \"Source of 95% problems\"\nauthor: \"Julien Martin\"\ninstitute: \"University of Ottawa\"\ndate: today\nfrom: markdown+emoji\nformat:\n  blackboard-revealjs: \n    width: 1244\n    height: 700\n    chalkboard: true\n#    output-location: column-fragment\n#    logo: assets/MAD_logo_small_rb.png\n    footer: Data in R\n    show-notes: false\n    output-ext: slides.html\n  html:\n    self-contained: true\n    number-sections: true\n    format-links: false\n    css: assets/css/notes.css\n    number-depth: 2\n    output-ext: notes.html\n    comments:\n      hypothesis: true\neditor:\n  render-on-save: false\n---\n\n\n## Learning outcomes\n\n\n\n\n\n- recognise different types of data in R ✔️\n\n- understand some different data structures ✔️\n\n- learn how to import data into R ✔️\n\n- learn how to manipulate data in R ✔️\n\n- learn how to export data from R ✔️\n\n\n\n\n\n\n## types of data in R\n:::: {.columns}\n::: {.column}\nsix types of data in R\n\n* **numeric** - 1.618, 3.14, 2.718 \n\n* **integers** - 1, 2, 3, 42, 101 \n\n* **logical** - TRUE or FALSE  \n\n* **character** - \"BI5009\", \"Blue\" \n\n* **complex**\n\n* **raw**\n:::\n::: {.column}\n![](assets/img/data_types.png)\n:::\n::::\n\n## data structures\n\n:::: {.columns}\n::: {.column}\nfive data structures\n\n* **vector** \n\n* **matrix** \n\n* **array** \n\n* **data frame**  \n\n* **list** \n:::\n::: {.column}\n![](assets/img/data_structures.png)\n:::\n::::\n\n\n## vectors\n\n:::: {.columns}\n::: {.column}\n- one dimensional collection elements \n\n- can contain all data types  \n\n- all elements must be of the same type \n\n\n::: {.cell}\n\n:::\n\n:::\n::: {.column}\n![](assets/img/scal_vec.png)\n:::\n::::\n\n## matrices and arrays\n\n:::: {.columns}\n::: {.column}\n- a vector with extra dimensions\n\n- again, objects must be of the same type \n\n- arrays are multidimensional matrices  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat.1 <- matrix(1:12, nrow=4)\nmat.1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    5    9\n[2,]    2    6   10\n[3,]    3    7   11\n[4,]    4    8   12\n```\n\n\n:::\n:::\n\n\n\n:::\n::: {.column}\n![](assets/img/mat_array.png)\n\n::: {.cell}\n\n```{.r .cell-code}\narray.1 <- array(1:16, dim=c(2,4,2))\n```\n:::\n\n:::\n::::\n\n\n## data frames\n\n\n- most commonly used data structure for statistical data analysis\n\n- powerful 2-dimensional vector holding structure\n\n- dataframes can hold vectors of any of the basic classes of data \n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n   treat nitrogen block height weight leafarea shootarea flowers\n1    tip   medium     1    7.5   7.62     11.7      31.9       1\n2    tip   medium     1   10.7  12.14     14.1      46.0      10\n3    tip   medium     1   11.2  12.76      7.1      66.7      10\n4    tip   medium     1   10.4   8.78     11.9      20.3       1\n5    tip   medium     1   10.4  13.58     14.5      26.9       4\n6    tip   medium     1    9.8  10.08     12.2      72.7       9\n7    tip   medium     1    6.9  10.11     13.2      43.1       7\n8    tip   medium     1    9.4  10.28     14.0      28.5       6\n9    tip   medium     2   10.4  10.48     10.5      57.8       5\n10   tip   medium     2   12.3  13.48     16.1      36.9       8\n```\n\n\n:::\n:::\n\n\n\n## tidy data\n![](assets/img/tidy-1.png){fig-align=\"center\"}\n\n\n## importing data\n\n:::: {.columns}\n::: {.column}\n- simplest method is to use spreadsheet  \nand then import data into R \n\n- save as a comma separated file (*.csv) \n\n:::\n::: {.column}\n![](assets/img/excel.png)\n:::\n::::\n\n## Importing data tips\n\n- missing data represented with NA or empty cells. Do not mixed both\n\n- No spaces in names (use underscore if needed)\n\n- no uppercase\n\n- keep variable names short & informative\n\n\n## importing data\n\n- the `read.table()` function is the workhorse with format specified function to make coding faster\n\n\n```r\n  petunia <- read.table('data/flowers.csv', header = TRUE, sep = ',')\n```\n\n\\\n\n|  |  |\n|------|-------------|\n| petunia | name of the new object |\n| read.table() | function use tot read tha data |\n| 'data/flowers.csv' | relative path name to the data file |\n| header = TRUE | first line contain columns names |\n| sep = ',' | columns sparated by commas |\n\n\n## importing data\n\n\n- sometimes columns are separated by tabs, `sep = \"\\t\"`\n``` r\npetunia <- read.table('data/flowers.csv', header = TRUE, sep = '\\t')\n```\n\n- you can use format specific functions\n```r\npetunia <- read.csv('flowers.csv')      # if comma-separated \npetunia <- read.delim('flowers.txt')      # if tab-separated\n```\n\n- functions in the `foreign` package allows you to import files of other formats (i.e. from SAS, SPSS, Minitab etc)\n\n- use the `readxl` or `readODS` package to directly import MS Excel or LO calc spreadsheets directly\n\n\n\n## importing data\n\n\n- to view the contents of a data frame, type it's name\n\n- rarely a good idea as just fills up your console\n\n- use the `head()` and `tail()` to see first/last 6 lines\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] flowers\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  treat nitrogen block height weight leafarea shootarea flowers\n1   tip   medium     1    7.5   7.62     11.7      31.9       1\n2   tip   medium     1   10.7  12.14     14.1      46.0      10\n3   tip   medium     1   11.2  12.76      7.1      66.7      10\n4   tip   medium     1   10.4   8.78     11.9      20.3       1\n5   tip   medium     1   10.4  13.58     14.5      26.9       4\n6   tip   medium     1    9.8  10.08     12.2      72.7       9\n```\n\n\n:::\n:::\n\n\n\n\n## data wrangling\n\n- `str()` function:  data frame dimensions, list of variables, type of variables\n\n\n::: {.cell}\n\n```{.r .cell-code}\n> str(flowers)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t96 obs. of  8 variables:\n $ treat    : chr  \"tip\" \"tip\" \"tip\" \"tip\" ...\n $ nitrogen : chr  \" medium\" \" medium\" \" medium\" \" medium\" ...\n $ block    : int  1 1 1 1 1 1 1 1 2 2 ...\n $ height   : num  7.5 10.7 11.2 10.4 10.4 9.8 6.9 9.4 10.4 12.3 ...\n $ weight   : num  7.62 12.14 12.76 8.78 13.58 ...\n $ leafarea : num  11.7 14.1 7.1 11.9 14.5 12.2 13.2 14 10.5 16.1 ...\n $ shootarea: num  31.9 46 66.7 20.3 26.9 72.7 43.1 28.5 57.8 36.9 ...\n $ flowers  : int  1 10 10 1 4 9 7 6 5 8 ...\n```\n\n\n:::\n:::\n\n\n## data wrangling\n\n- `names()` function: vector of variable names \n\n\n::: {.cell}\n\n```{.r .cell-code}\n> names(flowers)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"treat\"     \"nitrogen\"  \"block\"     \"height\"    \"weight\"    \"leafarea\" \n[7] \"shootarea\" \"flowers\"  \n```\n\n\n:::\n:::\n\n\n## data wrangling\n\n\n- access variables in your data frame using the `$` notation\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n> flowers$height\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  7.5 10.7 11.2 10.4 10.4  9.8  6.9  9.4 10.4 12.3 10.4 11.0  7.1  6.0  9.0\n[16]  4.5 12.6 10.0 10.0  8.5 14.1 10.1  8.5  6.5 11.5  7.7  6.4  8.8  9.2  6.2\n[31]  6.3 17.2  8.0  8.0  6.4  7.6  9.7 12.3  9.1  8.9  7.4  3.1  7.9  8.8  8.5\n[46]  5.6 11.5  5.8  5.6  5.3  7.5  4.1  3.5  8.5  4.9  2.5  5.4  3.9  5.8  4.5\n[61]  8.0  1.8  2.2  3.9  8.5  8.5  6.4  1.2  2.6 10.9  7.2  2.1  4.7  5.0  6.5\n[76]  2.6  6.0  9.3  4.6  5.2  3.9  2.3  5.2  2.2  4.5  1.8  3.0  3.7  2.4  5.7\n[91]  3.7  3.2  3.9  3.3  5.5  4.4\n```\n\n\n:::\n:::\n\n\n- you can extract elements using  the `[rowIndex, columnIndex]` method \n\n- `Index` can either be a positional index or a logical index\n\n\n## positional index\n\n\n- provide the row and column position of the data you wish to extract \n\n- `index` can either be a positional index or a logical index\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflowers[1, 4]      # extract value of first row and 4th column\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7.5\n```\n\n\n:::\n:::\n\n\n\n- extract multiple elements by supplying vectors \n\n\n::: {.cell}\n\n```{.r .cell-code}\nflowers[1:3, 1:4]      # extract rows 1 to 3 and columns 1 to 4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  treat nitrogen block height\n1   tip   medium     1    7.5\n2   tip   medium     1   10.7\n3   tip   medium     1   11.2\n```\n\n\n:::\n:::\n\n\n\n## positional index\n\n\n- another example\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflowers[c(3, 8, 20), c(1, 4, 5, 6)] # <1>\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   treat height weight leafarea\n3    tip   11.2  12.76      7.1\n8    tip    9.4  10.28     14.0\n20   tip    8.5  14.33     13.2\n```\n\n\n:::\n:::\n\n1. rows 3, 8 and 20 and columns 1, 4, 5 and 6\n\n- can assign these extracted values to another object if you want\n\n- new object inherits `data.frame` class\n\n\n``` r\nflowers_red <- flowers[c(3, 8, 20), c(1, 4, 5, 6)]\nflowers_red\n```\n\n\n## positional index\n\n\n- we can use a short cut if we want all rows or all columns extracted\n\n- omitting the column index is shorthand for 'all columns'\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n> flowers[1:3, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  treat nitrogen block height weight leafarea shootarea flowers\n1   tip   medium     1    7.5   7.62     11.7      31.9       1\n2   tip   medium     1   10.7  12.14     14.1      46.0      10\n3   tip   medium     1   11.2  12.76      7.1      66.7      10\n```\n\n\n:::\n:::\n\n\n\n- omitting the row index is shorthand for 'all rows'\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n> flowers[, 1:3]\n```\n:::\n\n\n\n\n## positional index\n\n\n- an alternative method to select columns is to name the columns directly for `columnIndex`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n> flowers[1:10, c('treat', 'nitrogen', 'leafarea', 'shootarea')]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   treat nitrogen leafarea shootarea\n1    tip   medium     11.7      31.9\n2    tip   medium     14.1      46.0\n3    tip   medium      7.1      66.7\n4    tip   medium     11.9      20.3\n5    tip   medium     14.5      26.9\n6    tip   medium     12.2      72.7\n7    tip   medium     13.2      43.1\n8    tip   medium     14.0      28.5\n9    tip   medium     10.5      57.8\n10   tip   medium     16.1      36.9\n```\n\n\n:::\n:::\n\n\n\n## logical index\n\n\n- we can also extract rows based on a logical test\n\n- example, all rows where the `height` variable is greater than 12 \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n> flowers[flowers$height > 12,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   treat nitrogen block height weight leafarea shootarea flowers\n10   tip   medium     2   12.3  13.48     16.1      36.9       8\n17   tip     high     1   12.6  18.66     18.6      54.0       9\n21   tip     high     1   14.1  19.12     13.1     113.2      13\n32   tip     high     2   17.2  19.20     10.9      89.9      14\n38   tip      low     1   12.3  11.27     13.7      28.7       5\n```\n\n\n:::\n:::\n\n\n\n- or where `leafarea` is equal to 8.7\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflowers[flowers$leafarea == 8.7,]\n```\n:::\n\n\n## logical index\n\n\n- we can combine logical tests using the `&` symbol (AND) or the `|` symbol (OR)\n\n- example, extract all rows where `height` is > 10.5 and `nitrogen` is equal to `\"medium\"`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflowers[flowers$height > 10.5 & flowers$nitrogen == 'medium',]\n```\n:::\n\n\n\n- or `height` is greater than 12.3 OR less than 1.8\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflowers[flowers$height > 12.3 | flowers$height < 1.8,]\n```\n:::\n\n\n## exporting data frames\n\n\n- the `write.csv()` function exports data frames to an external file\n\n\\\n\n\n```r\nwrite.csv(flowers, 'flowers2.csv', row.names = FALSE)\n```\n\n\\\n\n- saves `flowers` data frame to a file named 'flowers.csv'\n\n- `row.names = FALSE` argument supresses the row names in the file\n\n\n## other options\n\n- there are many other options for importing and exporting data in R\n\n- the `fread()` and `fwrite()` functions in the `read.table` package are blazingly fast\n\n- the `read_csv()` and `write_csv()` (and other related) functions from the `readr` package for tidyverse alternatives\n\n- if you have a lot of data (I mean alot!) then take a look at the `ff` and `bigmemory` packages\n\n\n\n\n# Thanks!\n\nCredit: I borrowed slides from [Alex Douglas](https://github.com/alexd106/)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}